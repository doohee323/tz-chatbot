# 슬라이드 02: 앱 생성과 워크플로우

## 슬라이드 내용 (한 장)

**Dify 앱**
• 챗봇 또는 워크플로우 형태
• 프롬프트·LLM·도구(Tool) 조합
• tz-chatbot: DrillQuiz용 앱, CoinTutor용 앱 각각 생성

**워크플로우 구조**
```
시작 → 챗봇 노드(LLM + 도구) → 끝
       ↓
       HTTP 도구 (RAG Backend /query)
```
• 도구: "지식 검색" 같은 HTTP 도구 추가
• URL: RAG Backend의 `/query` 등으로 설정

**앱별 RAG 도구 URL**
• **DrillQuiz**: `http://rag-backend-drillquiz.rag.svc.cluster.local:8000/query`
• **CoinTutor**: `http://rag-backend.rag.svc.cluster.local:8000/query`
• K8s **클러스터 내부** Service DNS (Ingress 아님)

**요청 흐름**
• 사용자 메시지 → chat-gateway → Dify API → 워크플로우 실행 → RAG 도구 호출

---

## 발표 노트

Dify에서 앱을 만드는 것부터 시작합니다. 앱은 챗봇 또는 워크플로우 형태입니다. 프롬프트(시스템 지시문), LLM 모델, 그리고 필요한 도구들을 조합해서 앱의 동작을 정의합니다.

워크플로우는 시작 노드에서 시작해서, 챗봇 노드로 가는데, 이 챗봇 노드가 LLM과 도구를 가지고 있습니다. 도구는 "지식 검색"이라는 이름의 HTTP 도구를 추가하고, URL을 RAG Backend의 /query 엔드포인트로 설정합니다. 그러면 사용자가 채팅할 때 필요하면 이 도구를 호출해서 지식을 검색할 수 있습니다.

앱은 토픽별로 만듭니다. DrillQuiz 앱의 RAG 도구 URL은 rag-backend-drillquiz의 Service DNS를 가리키고, CoinTutor 앱은 rag-backend(또는 rag-backend-cointutor)의 Service DNS를 가리킵니다. 이때 URL은 Ingress 경로가 아니라 K8s 클러스터 내부 Service DNS입니다. Dify가 K8s 내부에서 RAG Backend를 호출하니까요.

사용자가 메시지를 보내면 chat-gateway를 거쳐 Dify API로 전달되고, Dify가 해당 앱의 워크플로우를 실행합니다. 챗봇 노드가 필요하다고 판단하면 RAG 도구를 호출해서 관련 문서를 찾고, 그 문서를 참고해서 답변을 생성합니다.
